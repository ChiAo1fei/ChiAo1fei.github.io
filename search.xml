<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL主从配置]]></title>
    <url>%2F2018%2F07%2F13%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[在MySQL数据库中，支持单项、异步复制。在这个过程中，其中一个充当主服务器(master),另外一个便充当从服务器(slave)，在进行好配置后，主服务器会将更新信息写入到一个特定的二进制文件。并且会维护文件的一个索引来更总日志循环，这个日志的作用可以记录并且发送到从服务器中进行更新。 主从配置的优点： 实现服务器的负载均衡 通过复制来实现数据的异地备份 提高数据库系统的可用性 1 部署环境MySQL可以在windows、Linux、IOS系统上安装，推荐MySQL，一般的生产环境为Linux。 在Linux下安装MySQL： 1yum install mysql-server 在windows下可直接去官网下载。 ###2 配置 ####2.1 配置主服务器(master) Linux下： 123456789vim etcmy.confserver-id = 200 # 设置主服务器的IDinnodb_flush_log_at_trx_commit = 2# 操作系统崩溃或者系统断电的情况下，上一秒的所有事务数据才可能丢失sync_binlog = 1 # 开启binlog⽇日志同步功能log-bin=mysql-bin-200 # binlog⽇日志⽂文件名，这里的ID必须shi master的IDbinlog-do-db = xxxx # 这个表示只同步某个库 （如果没有此项，表示同步所有的库） Windows下: 若安装的是默认路径，则在路径$$C:\ProgramData\MySQL\MySQL Server$$下寻找$$my.ini$$这是一个隐藏文件，找到之后在其中添加的内容和Linux下添加的内容一样。 2.2 配置完成后，重启MySQL数据库注意:是重启数据库这个服务，并不是重新登录数据库 1234# Linux：service musqld restart# Windows# 找到MySQL服务，然后重启 之后在数据库中进行操作 12345mysql -u -p ## 登录数据库grant replication slave on *.* to &apos;mark&apos;@&apos;192.168.1.201&apos; identifined by&apos;123456&apos;;## 对从服务器进行授权 用户名为mark, 密码为123456， IP地址为192.168.1.201show master status;## 查看主库的状态 查看主数据库的状态时会出来一个表格，请记住此表格的File字段和Position的值，在从数据库配置时需要用到这两个值。在这个示例中，这两个值分别为mysql-bin-200.0000002和1167。 2.3 配置从数据库还是找个MySQL的配置文件，做如下改动： 123456server-id=201# 这里的id是从服务器的ID，但是不可与主服务的ID一致innodb_flush_log_at_trx_commit=2sync_binlog=1log-bin=mysql-bin-201# 为从服务器ID 2.4 重启从数据库重启方法相同 1234567mysql -u -pchange master to master_host=&apos;192.168.1.200&apos;, master_user=&apos;mark&apos;, master_password=&apos;123456&apos;,master_log_file=&apos;mysqlbin-200.000002&apos; ,master_log_pos=1167;## IP 为主数据库IP， mark为当前数据库用户名， 密码为当前数据库密码 后面两个值是之前记录的值start slave; ## 开启从数据库(stop slave 关闭数据库)show slave status \G;## 当Slave_IO_Running,Slave_SQL_Running 都为Yes的时候表示配置成功 2.5 验证主从在主数据库上创建一个库，在从数据库上刷新并查看是否存在数据库。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask基础]]></title>
    <url>%2F2018%2F03%2F20%2Fflask%2F</url>
    <content type="text"><![CDATA[Flask创建 这一篇主要讲Flask的基础内容，目前还在持续更新 安装环境 使用virtualenv创建环境 安装virtualenv 1pip install virtualenv 创建虚拟环境： 1virtuallen --no-site-packages -p 安装位置 激活环境 1234window环境下:cd 安装位置 Scripts 执行activateLinux/MAC环境下：source activate 使用pycharm直接创建环境 安装flask 在装好并且激活环境后在当前环境下安装flask 1pip install flask 启动 现在最基本的flask的环境就搭好了，如下应用： 1234567891011121314# 首先要导入flask的包from flask import Flask# 生成flask对象app = Flask(__name__)# 创建一个最基本的路由@app.route('/')def hello(): return 'hello world' #执行if __name__ == '__main__': app.run(host='127.0.0.1'， port=80, debug=True) 这只是最基础的一个flask小应用，这是flask自带的启动方式，但是在实际开发中要用另一个。python中有一个管理工具：fllask-scripts.应用如下： 1234567891011121314# 首先要先安装flask-scriptspip install flask-scripts# 导入flask-scripts中的Managerfrom flask_scripts import Manager# 管理启动命令manage = Manager(app)# 执行if __name__ == '__main__': # app.run(host='127.0.0.1', port=80, debug=True) # 这样把之前的启动命令注释掉写下面的命令就可以了 manage.run() 注意：使用manage时，在pycharm的右上角的运行图标的左面，点击’编辑配置’ ，在‘Parameters’一行填入 -p 端口号 -d(开启调试模式) 括号里的不写，地址默认为127.0.0.1。之后每次点击运行图标就可以了。 路由规则 请求与相应 cookie与session 装饰器 蓝图 模板 模型]]></content>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰器]]></title>
    <url>%2F2018%2F03%2F11%2F%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[装饰器 在代码运行期间，希望增强某个函数的功能，但是又不想修改这个函数的原本结构，这种在代码运行期间动态的增加功能的方式，叫做装饰器(Decorator)。 Decorator本身就是一个返回函数的高阶函数， 举个例子 12def now(): print '2019-3-6' 这个函数本身的功能是打印一个时间，当然这是一个基本的打印函数，也可以打印当前时间。 现在，想要增强上述函数now()的功能，比如，想要在函数调用前后自动打印日志，但是，又不想修改now()函数本身，因此我们需要用到装饰器。 因此，现在我们需要定义一个能打印日志的装饰器： 12345def log(func) def wrapper(*args, **kw): print 'call %s()' % func.__name__ return func return wrapper 现在来分析一下上面的log函数，因为他是一个装饰器，所以接受一个函数作为参数，并且返回一个函数，我们需要借助python的语法，将装饰器放到 now()函数的头部，像这样： 123@logdef now(): print '2019-3-6' 现在在执行now函数的时候，不仅会执行now函数本身，并且会在运行now函数前打印一行日志： 12call now():2019-3-6 因为把log函数放在now函数的定义的地方，相当于执行了语句 1now = log(now) 由于log函数是一个装饰器，返回了一个函数。所以原来的now函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now函数将执行新函数，即在log函数中返回的wrapper函数 wrapper函数的参数定义的是可以接任意参数，在wrapper函数内，首先打印日志，然后调用原始函数。 ———————————————————————————————————————————— 高级用法如果说装饰器本身需要传入参数，那么就编写一个返回装饰器的告诫函数，写出来那是更复杂，比如，想要自定义上述函数打印的log，如下： 1234567def log(text): def decorator(func): def wrapper(*args,**kw): print '%s %s()' % (text，func.__name__) return func return wrapper return decorator 上述代码可以这样用 123@log('execute')def now(): print '2019-3-6' 结果如下： 12execute now():2019-3-6 和两层嵌套相比，三层嵌套的效果是这样的： 1now = log('execute')(now) 分析一下步骤： 首先执行log(‘execute’),返回的是decorator函数， 然后调用返回的decorator函数，参数是now函数。返回值是wrapper函数 最后一步，上述两种定义装饰器的方法，都没有问题，但是还有最后一步，因为我们所说的函数有name属性，但是在经过decorator装饰的函数，他们的name已经从雨来的now变成了wrapper 1now.__name__ == 'wrapper' 因为返回的那个wrapper函数的名字就是wrapper 所以，需要吧原始的name属性复制到wrapper函数中，否则会出错]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连接查询、权限、事务]]></title>
    <url>%2F2018%2F02%2F27%2F%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E3%80%81%E6%9D%83%E9%99%90%E3%80%81%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[连接查询是关系数据库中最主要的查询，主要包括内连接、外连接和交叉连接等。通过连接运算符可以实现多个表查询。连接是关系数据库模型的主要特点，也是它区别于其它类型数据库管理系统的一个标志。 在关系数据库管理系统中，表建立时各数据之间的关系不必确定，常把一个实体的所有信息存放在一个表中。当检索数据时，通过连接操作查询出存放在多个表中的不同实体的信息。连接操作给用户带来很大的灵活性，他们可以在任何时候增加新的数据类型。为不同实体创建新的表，然后通过连接进行查询。 一、连接查询 连接查询：同时查询多个表中的内容 123456789101112131415161718-- SELECT * FROM 表名1，表名2... WHERE 连接条件-- 表.字段-- 连接查询时如果不加连接条件，结果就是笛卡尔积-- 获取学生的姓名和对应的学科的分数SELECT stuname, couname,mark FROM tb_student,tb_course,tb_scoreWHERE tb_student.stuid = tb_score.stuid AND tb_score.couid = tb_course.couid;-- 查询学生姓名 对应的学生的平均成绩SELECT stuname,AVG(mark) FROM tb_student, tb_score WHERE tb_student.stuid = tb_score.stuid GROUP BY tb_score.stuid;SELECT stuname,avgMark FROM tb_student,(SELECT stuid,AVG(mark) AS avgMark FROM tb_score GROUP BY stuid) as tb_2 WHERE tb_student.stuid = tb_2.stuid;SELECT stuid,AVG(mark) FROM tb_score GROUP BY stuid;-- 查询平均分高于80的SELECT stuname,AVG(mark) FROM tb_student, tb_score WHERE tb_student.stuid = tb_score.stuid GROUP BY tb_score.stuid HAVING AVG(mark) &gt;= 80;-- 注意：如果连接查询的时候既有连接条件又有筛选条件，要把筛选条件写到连接条件的后面 内连接 1234-- SELECT * FROM 中间关系表 INNER JOIN 表1 ON 条件 INNER JOIN 表2 ON 条件 ..-- 中间关系表写在前面(存在关联其他表外键的表)-- 获取学生的姓名和对应的学科的分数SELECT stuname,couname,mark FROM tb_score INNER JOIN tb_student ON tb_student.stuid = tb_score.stuid INNER JOIN tb_course ON tb_course.couid = tb_score.couid WHERE mark &lt; 60; 外连接 外连接分为左外连接，和右外连接，全连接，但是MySQL中不支持全连接 左外连接：先取出左边表所有的数据再匹配条件，不满足的为空 右外连接：先取出右边表所有的数据在匹配条件，不满足的为空 12-- 表1 LEFT JOIN 表2 ON-- 表1 RIGHT JOIN 表2 ON 二、字段索引字段的索引相当于一个目录，作用是为了能够快速的对这个字段进行查找 添加索引的好处可以大大的提高查询效率，缺点是1:消耗额外的存储空间2:会让 添加和删除的效率降低 建议：1.索引不能滥用 2.如果项目中针对某个字段的查询很频繁 123456789EXPLAIN SELECT * FROM tb_student WHERE stuname = &apos;杨永信&apos;;-- 在SQL语句中添加 EXPLAN : 获取执行计划-- 添加索引: CREATE INDEX 索引名称 ON 表名(字段名) - 给指定表中的指定字段添加索引CREATE INDEX index_stuname ON tb_student(stuname);CREATE INDEX index_stuname1 ON tb_student(stuname(1)); -- 按姓名加索引-- 删除索引ALTER TABLE tb_student DROP INDEX index_stuname; 三、DCL 创建用户 123-- create user 用户名@登录地址-- 登录地址：(限制用户能够登录mySQL的主机地址),ip地址(指定ip地址),localhost(数据库本机),%(任何位置)CREATE USER &apos;guorui&apos;@&apos;%&apos; IDENTIFIED BY &apos;nimabi123&apos;; 授权 12-- 授权: grant 授权类型 on 数据库.对象 to 用户 (WITH GRANT OPTION) ; 括号里表示 可以让当前用户授权给其他用户GRANT SELECT ON school.tb_student TO &apos;guorui&apos;; 召回授权 1-- REVOKE 授权类型 on 数据库.对象 FROM 用户 删除用户 12-- 删除用户(root用可以删除所有用户)DROP USER &apos;guorui&apos;; 事务 完成一个任务需要执行多条SQL语句的操作，但是要求这多个操作中只要有一个操作失败，这个任务就失败，数据全部还原，所有的操作都成功，整个任务才成功的时候，就使用事务 123-- BEGIN 开启事务环境-- COMMIT 提交事务(只有begin到commit之间的所有sql都执行成功才会执行commit)-- ROLLBACK 事务回滚(放弃begin 到 COMMIT 之间执行陈宫的所有的sql语句的结果)]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[外键约束]]></title>
    <url>%2F2018%2F02%2F26%2F%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F%2F</url>
    <content type="text"><![CDATA[如果公共关键字在一个关系中是主关键字，那么这个公共关键字被称为另一个关系的外键。由此可见，外键表示了两个关系之间的相关联系。以另一个关系的外键作主关键字的表被称为主表，具有此外键的表被称为主表的从表。外键又称作外关键字。 ###一、上一章的补充 条件语句的写法在SQL中可以通过 WHERE 条件语句 来对操作对象进行筛选 比较运算符 ： =，&gt;=,&lt;=, &lt;,&gt;,,&lt;&gt;注意：判断一个字段的值是否为空不能使用 = 和&lt;&gt;,而是使用 is null 和 is not null 逻辑运算符：and or not WHERE 字段名 BETWEEN 值1 AND 值2 - 筛选指定的字段的值在值1和值2之间 WHERE 字段 in 集合筛选出字段的值是集合中的元素，集合是用括号括起来里面多个值 like操作 数据类型VARCHAR(size): 不定长字符串，size决定最大长度char(size): 定长字符串，text:不限长度，(最大长度255个字符)int:float/doublebit：只有01两个值date/datetime/time ：值可以是时间函数的结果，也可是时间字符串；计算或者比较的时候是按内部时间来算de 去重在字段前面 加 DISTINCT 二、添加约束 创建表的时候添加约束： 123456CREATE TABLE IF NOT EXISTS t_college(collid INT,cloname VARCHAR(20) NOT NULL, -- 创建表的时候添加约束website VARCHAR(1024),intro VARCHAR(200),PRIMARY KEY(collid)); 通过添加约束索引的方式来添加约束 123456789-- 2.通过添加约束索引的方式添加约束-- alter 表名 add CONSTRAINT 索引名 约束(字段名);-- 说明：索引名 - 自己随便命名，用来指向当前添加的约束；约束 - 需要添加的约束ALTER TABLE t_college ADD CONSTRAINT con_website UNIQUE(website); -- 给t_college表中的website添加unique约束，约束的索引为con_webisite-- b.删除约束-- alter table 表名 drop index 索引名ALTER TABLE t_college DROP INDEX con_website; 三、外键和ER图 什么是外键 表中的某个字段的值是根据其他表中主键的值，那么这个字段就是外键。 多对一的外键的添加：将外键添加到多的一方对应的表中 一对一的外键的添加：将外键随便添加到哪一方，同时添加唯一值约束多对多的外键的添加：关系型数据库中两张表是无法实现多对多的关系，需要一个中间表(中间表有两个外键，分别参照多对多的两个表的主键) 怎么添加外键: 添加外键对应的字段 给设计好的外键对应的字段添加外键约束 12-- ALTER TABLE 表名1 ADD CONSTRAINT 索引名 FOREIGN KEY (字段1) REFERENCES 表2(字段2)-- 将表1中的字段1设置为外键，并且让这个外键的值参照表2中的字段2 删除外键约束 123-- 注意：删除外键约束的时候直接删除约束的索引无效，必须先将约束删掉，然后在删除索引-- alter table 表名 drop foreign key 索引名; - 可是删除外键约束，但是外键索引还存在，需要重新把索引删掉-- alter table 表名 drop index 索引名 多对多的外键约束 创建两个表的关系表，两张表的主键分别是关系表的外键。 ###四、查询的高级操作 聚合: max/min/sum/avg/count 12345678910-- SELECT 聚合函数(字段) FROM 表名 where 条件; - 按条件多表查询指定字段数据，然后将查询结果做相应的聚合运算，聚合运算的结果是最后结果-- 取所有分数SELECT mark FROM tb_score;-- 取分数最大值SELECT MAX(mark) AS maxmark from tb_score;SELECT MIN(mark) AS minmark from tb_score;SELECT SUM(mark) AS summark from tb_score;-- 计算平均值时，若果参与运算的对象值为null,那这个数据不会参与运算SELECT AVG(mark) AS avgmark from tb_score;SELECT COUNT(mark) AS countmark from tb_score WHERE mark &gt; 90; 分组 1234567-- SELECT 字段操作 FROM 表名 WHERE 条件 GROUP BY (字段2); - 将指定表中满足条件的记录按照字段2的值进行分组(值一样的在一个组里)，然后再将每个分组作为整体按照指定字段进行聚合操作-- 注意：a.字段操作的位置除了分组字段不用聚合，其他字段必须聚合-- b.分组的时候where要放到分组前对需要分组的数据进行筛选-- 求每个学生的平均成绩-- SELECT COUNT(mark) FROM tb_score GROUP BY (mark);-- having - 对分组后的数据进行筛选 子查询: 将一个查询操作的结果作为另外一个查询的数据源 1234567891011-- 在tb_score表中获取成绩是大于90分的学生的idSELECT stuid FROM tb_score WHERE mark&gt;90 and stuid is not NULL; -- 获取成绩大于90分的学生的名字SELECT stuname FROM tb_student WHERE stuid in (SELECT stuid FROM tb_score WHERE mark&gt;90 and stuid is not NULL); SELECT stuid,mark FROM tb_score WHERE mark &gt; 90 and stuid is not NULL;-- 将一个查询的结果作为查询对象提供给另外一个查询。但是第一个查询结果需要重命名SELECT mark FROM (SELECT stuid,mark FROM tb_score WHERE mark &gt; 90 and stuid is not NULL) as t2;]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx服务器的搭建]]></title>
    <url>%2F2018%2F02%2F23%2FNginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Nginx (engine x) 是一个高性能的HTTP和反向代理服务，也是一个IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。 其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。 Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。 1.阿里云添加80端口阿里云上默认只有一个22端口用来做远程登录，如果希望在阿里云上安装支持http请求的nginx服务器，需要给阿里云添加80端口 2. 安装nginxa) 添加nginx存储库 1yum install epel-release b) 安装nginx 1yum install nginx c) 运行nginxNginx不会自行启动。要运行Nginx 1systemctl start nginx nginx的运行命令: 12systemctl status nginx 查看nginx的状态 systemctl start/stop/enable/disable nginx 启动/关闭/设置开机启动/禁止开机启动 d) 系统启动时启动Nginx 1systemctl enable nginx e）如果您正在运行防火墙，请运行以下命令以允许HTTP和HTTPS通信： 12345sudo firewall-cmd --permanent --zone=public --add-service=http sudo firewall-cmd --permanent --zone=public --add-service=httpssudo firewall-cmd --reload 3.nginx目录共享配置a) 在contOS目录中确定一个需要共享的文件夹，例如： /home/yutingb) 打开 etc/nginx/nginx.conf 文件，设置server 1234567#共享设置 - 在浏览器中输入服务器ip地址，会展示共享目录的文件列表root /home/yuting;location / &#123; autoindex on; autoindex_exact_size on; autoindex_localtime on;&#125; 除了可以共享文件，还可以自定义页面 12345#自定义服务器页面location / &#123; root /home/yuting; index index.html index.htm;&#125; 注意： 如果出现权限问题，可以修改目录的权限 ssh密钥认证1.在主机和从机上执行：ssh-keygen 2.在从机上执行: scp id_rsa.pub root@主机地址:~/.ssh/master.pub(上面这条指令是将从机上的 id_rsa.pub文件拷贝传递给到主机的.ssh文件夹下，并且命名为’master.pub’) 3.在主机中的.ssh文件夹中创建authorized_keys文件： touch authorized_keys 4.修改文件authorized_keys的权限: chmod 600 authorized_keys 5.将master.pub放进authorized_keys文件中: cat master.pub &gt;&gt; authorized_keys 6.在操作主机的时候，需要主机能够自己免密访问自己就将自己的公钥放在自己的authorized_keys文件中]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim 编辑器之神]]></title>
    <url>%2F2018%2F02%2F23%2Fvim%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8B%E7%A5%9E%2F</url>
    <content type="text"><![CDATA[Vim是一个类似于Vi的著名的功能强大、高度可定制的文本编辑器，在Vi的基础上改进和增加了很多特性。VIM是自由软件。 Vim普遍被推崇为类Vi编辑器中最好的一个，事实上真正的劲敌来自Emacs的不同变体。1999 年Emacs被选为Linuxworld文本编辑分类的优胜者，Vim屈居第二。但在2000年2月Vim赢得了Slashdot Beanie的最佳开放源代码文本编辑器大奖，又将Emacs推至二线， 总的来看， Vim和Emacs在文本编辑方面都是非常优秀的。 配置vimrc配置在shell中可以通过 vim ~/.vimrc 或者 vim /etc/vimrc 打开vimrc文件对vim进行配置。在这个文件中可以进行很多和vim相关的配置，常用的如下（如果对其他配置感兴趣的可以自己百度）： 常用操作1.模式切换我们可以将vim分为命令模式、编辑模式和末行模式三种命令模式：进入vim的时候vim是处于命令模式状态下的，这个时候输入内容不会出现在编辑区 (最末什么都没有) 末行模式：在命令模式下输入冒号，让vim进入末行模式。在末行模式的冒号后面可以输入相关的一些指令进行相关操作 (最后有一个冒号) 编辑模式：在命令模式下按’i’进入编辑模式。在编辑模式下可以对文件内容进行编辑 (最后 –INSERT– 或者 –插入–) ####2.保存和退出在末行模式下输入相应的指令可以对编辑区的内容进行保存和退出vim界面w – 只保存(类似快捷键ctr+s)q – 退出（在编辑区的内容全部都保存的情况下才有效）wq – 保存并退出q! – 强制退出（不保存修改信息） ####3.光标操作以下光标操作都是在命令模式下输入的^(shift+6) – 移动到行首$(shift+4) – 移动到行尾G(shift+g) – 移动到文件末尾行号G – 移动到指定行,例如:30G, 让光标直接跳转到行号是30的那一行gg – 移动到文件开头 ####4.文本操作以下操作不带冒号的是在命令模式下输入，前面有冒号代码后面的内容是在末行模式下输入dd – 删除光标所在的行数字dd – 从光标所在行开始往后面开始删，删除指定数量行内容:%d – 删除所有 yy – 复制光标所在的行数字yy – 从光标所在行开始复制指定行数的内容p – 将复制的内容粘贴到光标所在的位置u – 撤销ctr+r – 反撤销 :%!sort – 对内容排序 :/查找对象[/gice] – 搜索匹配正则表达式的内容，按回车回到命令模式后按n往前查找，按N往后查找 *:1,$s/被替换对象/替换内容[/gice]* – 将正则表达式匹配到的内容替换成指定内容 - g: 全局匹配 - i: 忽略大小写 - c: 替换时需要提示 - e: 忽略错误]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux指令]]></title>
    <url>%2F2017%2F06%2F23%2FLinux%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[linux命令是对Linux系统进行管理的命令。对于Linux系统来说，无论是中央处理器、内存、磁盘驱动器、键盘、鼠标，还是用户等都是文件，Linux系统管理的命令是它正常运行的核心，与之前的DOS命令类似。linux命令在系统中有两种类型：内置Shell命令和Linux命令。 命令名称 [命名参数] [命令对象] 一、日常操作1.cd指令 - 进入指定文件夹cd 目录 - 进入指定目录(也可以是文件夹对应的路径) ~相对路径 — 绝对路径 cd .. - 返回上层目录cd ~ - 回到根目录 ls指令 - 查看当前目录中的内容lsls -l/-lh ls -a - 隐藏文件也一起显示 ls -R - 递归显示所有内容 ls -S/-t - 按大小/时间排序 3.pwd指令 - 显示当前完整目录pwd 4.文件操作指令touch 文件名 - 新建文件cat 文件名 - 查看文件内容 rm 文件名 - 删除文件rm - r 目录 - 删除文件夹 cp 文件名1 文件名2 - 将文件1中的内容拷贝到文件2中cp -r 文件名/目录名 目录2 - 将文件/目录拷贝到目录2中 mv 文件名1 文件名2 - 将文件1中的内容移动到文件2中 ,并且删除文件1（文件重命名）mv 文件名1 文件目录 - 将文件1移动到指定目录中 (注意：cp/mv/rm 后面可以跟： -i询问 -f强制 -n不覆盖) mkdir 目录名 - 新建文件夹mkdir -p a/b/c - 按层级创建a,b,c三个文件夹mkdir -p a/{b,c}/{d,e,f} -同一层级常见多个 rmdir 目录名 - 删除指定空目录 7.history - 显示历史指令记录bashrc 配置显示时间：export HISTTIMEFORMAT=”[%y‐%m‐%d_%T] “修改bashrc 后使其生效: source ~/.bashrc 或 . .bashrc 6.链接ln -s 源路径 目标路径 - 给源路径对应的文件在目标路径下创建一个软链接(可以看成是快捷键)ln 源路径 目标路径 - 给源路径对应的文件在目标路径下创建一个硬链接 8.快捷键ctr + f - 前进一个字符ctr + b - 后退一个字符ctr + a - 回到行首ctr + e - 回到行尾ctr + w - 向左删除一个单词ctr + u - 向左删除全部ctr + k - 向右删除全部ctr + y - 粘贴上次删除的内容ctr + l - 清屏 二、进程相关指令1.ps指令ps - 进程状态ps -aux 或者 ps ex - 查看进程ps -aux|grep 进程名 - 查看指定进程psgrep 进程名 2.top指令top - 动态监控进程top -p PID1,PID2,…. - 动态监控指定进程 3.free指令free -单位 - 以指定单位查看内存 4.kill指令 kill 进程号 - 杀死指定的进程kill -1/-9/-15 - -1(HUP)不间断重启，-9(KILL)强制杀死进程,-15(TERM)正常终止进程pkill 进程名 - 按名字处理进程killall 进程名 - 处理名字匹配的进程 uptime - 查看系统状态 三、权限管理1.user和group users -查看当前用户groupadd 分组名 - 添加分组useradd ‐G 分组列表 ‐m ‐s /bin/bash 用户名 - 创建一个用户添加到指定的分组中usermod -G 分组列表 用户名 - 修改分组sudo - 以管理员执行其他程序su - 用户名 - 切换用户身份]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL语法 1]]></title>
    <url>%2F2017%2F05%2F25%2FMySQL%E8%AF%AD%E6%B3%951%2F</url>
    <content type="text"><![CDATA[DDL(数据定义语言) DML(数据操作语言) DCL(数据控制语言) 注意:SQL中大小写不敏感，每条数据库语句必须以分号结束 一、DDL - 主要提供数据库和表的创建、删除和修改 删除数据库 12345-- drop database 数据库名drop database school;drop database if exists school2; -- 如果指定的数据库存在就删除 创建数据库 1234567-- create database 数据库名;CREATE database school;create database if not exists school2;create database if not exists school2 default charset utf8;-- 创建数据库的时候设置字符集编码方式为：utf8 让数据库支持中文 使用数据库 12-- use 数据库名；USE school2 新建表 1-- create table if not EXISTS 表名(字段1 类型 约束， 字段2 类型， 字段3 类型) 注意：a.表名一般需要加前缀‘t’或者‘tb’ b.字段是用来确定表中要存储哪些数据，可以随便命名，但是不能是关键字 c.数据类型必须是mysql支持的类型 数据类型: int char(size)-定长 varchar(size)-不定长 text-字符串 bit - 布尔 date-日期 常用的约束 not null - 不能为空 DEFAULT 设置默认值，UNIQUE 值唯一 PRIMARY KEY 主键约束 主键约束： 主键是这张表中能够标识唯一一条记录的字段(通过主键值能够找到表中唯一一条记录) 123456789CREATE TABLE IF NOT EXISTS tb_student(stu_id INT NOT NULL auto_increment, -- auto_increment 只针对主键有效，并且主键的类型是int stu_name VARCHAR(20), stu_sex bit DEFAULT 1, stu_birth date, PRIMARY KEY(stu_id) -- 设置stu_id为当前表的主键，设置一个字段为主键，相当于间接的约束了这个字段的值是唯一的 ); -- 注意注意注意注意： 创建表的时候如果字段为中文 则不用加引号！！！！！！！！！！！！！！！！！！！！！！！ 删除表 123DROP table if EXISTS tb_student;TRUNCATE TABLE tb_student;-- 清空表中的记录：TRUNCATE table 表名 - 表还在，只是记录没有了 修改表 12-- 添加字段 ALTER TABLE 表名 add COLUMN 字段名 字段类型 约束ALTER TABLE tb_student add COLUMN score FLOAT(5,2) DEFAULT 0; 12-- 删除字段ALTER TABLE tb_student drop COLUMN stu_sex; 二、DML(数据操作语言) - 主要针对数据库中数据的增删改查 增(添加数据/ 记录) 插入数据/记录 123-- insert into 表名 values(值1，值2，值3...)-- 依次给指定表中的字段赋值(into可以省略)INSERT tb_student VALUES (3, &apos;大黄&apos;, &apos;2018-2-23&apos;,88); 插入数据/记录 123-- insert into 表名 (字段1，字段2，字段3···) values (值1，值2，值3···) - 以指定的顺序给指定的字段赋值INSERT tb_student (stu_name, stu_birth) VALUES (&apos;小王&apos;, &apos;2018-02-14&apos;);INSERT tb_student (stu_name, stu_birth) VALUES (&apos;大黄&apos;, DATE(NOW())); 插入多条数据/记录 12345INSERT tb_student (stu_name, stu_birth) VALUES (&apos;张三&apos;,&apos;2018-02-23&apos;), (&apos;李四&apos;,&apos;2018-02-24&apos;), (&apos;王五&apos;,&apos;2018-02-25&apos;), (&apos;赵六&apos;,&apos;2018-02-26&apos;); 其他注意事项： 1234-- 值的问题: sql中是数字对应的值直接写，字符需要使用引号，bit类型的值是0或1，时间可以用满足时间格式的字符串也可是通过时间函数获取的值-- 时间函数: now() - 当前时间SELECT year(NOW());SELECT DATE(NOW()); 删(删除数据/记录) 1234567-- DELETE FROM 表名; - 删除指定表中所有的记录-- DELETE FROM 表名 WHERE 条件语句; - 删除满足条件的语句-- SQL语句中的条件语句: =(判断是否相等)，&lt;&gt;(不等于，和python中的!=一样)，&gt;,&lt;,&gt;=,&lt;=DELETE FROM tb_student WHERE stu_id = 2DELETE FROM tb_student WHERE stu_name = &apos;郭锐&apos;DELETE FROM tb_student WHERE stu_id &gt;= 5 改(修改数据/记录) 123456789101112131415-- update 表名 set 字段1=新值1, 字段2=新值2; - 将指定表中的所有行的指定列/字段值赋值为新值UPDATE tb_student SET stu_birth = DATE(NOW())-- update 表名 set 字段1=新值1, 字段2=新值2 WHERE 条件语句; - 将表中满足条件的行中指定字段的值赋为新值UPDATE tb_student SET score = 88 WHERE stu_birth = DATE(NOW())UPDATE tb_student SET score = 98 WHERE stu_name = &apos;赵六&apos;-- 通配符%: 表示任意个数的任意字符(包括0个)UPDATE tb_student SET score = 78 WHERE stu_name LIKE &apos;王%&apos; -- 修改当前表中stu_name字段中以 王 开头的名字UPDATE tb_student SET score = 78 WHERE stu_name LIKE &apos;%王%&apos; -- 名字中只要有王 就修改-- 通配符_: 表示一个任意字符-- 注意：通配符 只针对字符串有效 查(获取数据/记录) 直接查询 12345678 SELECT * FROM 表名; - 获取指定表中所有的行和列(所有数据)SELECT * FROM tb_student;-- SELECT 字段1，字段2，···· FROM 表名; - 获取指定表中所有行的指定列SELECT stu_name, stu_birth FROM tb_student;-- SELECT * FROM 表名 WHERE 条件; - 获取指定表中满足条件的行SELECT * FROM tb_student WHERE score &lt; 80 列重命名 123-- SELECT 字段1 as 新字段1， 字段2 AS 新字段2··· FROM 表名;-- AS 可以省略SELECT stu_name AS stuName FROM tb_student WHERE stu_name LIKE &apos;%王%&apos;; -- 对满足条件的查询结果重命名 对查询结果重新赋值，一般针对布尔数据 1234567891011-- SELECT IF(字段相关的条件语句,值1,值2) FROM 表名 - 查询指定字段，并且哦按段字符对应的值是0还是1，如果是1结果为值1，否则为值2 -- 这里IF的用法是MySQL专有的SELECT stu_name AS &apos;姓名&apos;, IF(stu_sex,&apos;男&apos;,&apos;女&apos;) AS &apos;性别&apos; FROM tb_student;-- 通用写法 - case 字段1 WHEN 值 THEN 值1 ELSE 值2 END 与上面的if效果一样 一般需要重命名SELECT CASE stu_sex WHEN 1 THEN &apos;男&apos; ELSE &apos;女&apos;END AS &apos;性别&apos; FROM tb_student; 对列进行合并运算 123-- SELECT CONCAT(字段1,字段2,...) FROM 表名SELECT CONCAT(stu_id,&apos;: &apos;,stu_name) AS &apos;学号:姓名&apos; FROM tb_student;-- 注意: 数字和字符串类型的可以合并，bit类型的数据不可以合并 模糊查询 - 查询的时候通过like条件来指定查询对象 12-- SQL中支持逻辑运算符and(逻辑与运算)和or(逻辑或运算)SELECT * FROM tb_student WHERE stu_name LIKE&apos;_三%&apos; OR stu_sex = 0 对查询结果进行排序 123456-- SELECT * FROM 表名 ORDER BY 字段 ASC(默认升序，一般省略); - 对查询结果按照指定的值进行升序排序-- SELECT * FROM 表名 ORDER BY 字段 DESC, 字段2 ,; - 对查询结果按照指定的值进行降序排序 如果有相等的，则相等的按照字段2进行排序,前面的字段的优先级高SELECT * FROM tb_student ORDER BY stu_name;SELECT * FROM tb_student ORDER BY stu_id DESC;SELECT * FROM tb_student ORDER BY stu_sex ASC , stu_id DESC; 限制 对查询结果的条数进行限制 1234-- SELECT * FROM 表名 LIMIT 数字; - 获取查询结果的前指定数量条结果SELECT * FROM tb_student LIMIT 2; -- 获取查询结果的前两条记录-- SELECT * FROM 表名 LIMIT M OFFSET N - 对查询结果跳过前N条，取M条数据出来SELECT * FROM tb_student LIMIT 2 OFFSET 3;]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL配置]]></title>
    <url>%2F2017%2F05%2F23%2FMySQL%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[下周要开始学Django等python后台框架，先在Linux系统中把MySQL的环境配置好 下载MySQL源安装包: wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm 安装MySQL源: yum localinstall mysql57-community-release-el7-8.noarch.rpm 安装MySQL: yum install mysql-community-server 设置开启启动MySQL服务: systemctl enable mysqld 启动/重启MySQL服务：systemctl restart mysqld 查看MySQL初始密码：grep ‘A temporary password’ /var/log/mysqld.log 更改MySQL密码：mysqladmin -u root -p’旧密码’ password ‘新密码’这里更改密码出了问题，更改失败，这是因为密码太过简单的原因。有两个接解决方法： 方法一：把密码设置复杂点（这是最直接的方法） 方法二：关闭mysql密码强度验证(validate_password) 编辑配置文件：vim /etc/my.cnf， 增加这么一行validate_password=off 编辑后重启mysql服务：systemctl restart mysqld 设置mysql能够远程访问:a. 登录进MySQL: mysql -uroot -p密码b. 增加一个用户给予访问权限: grant all privileges on *.* to &#39;root&#39;@&#39;ip地址&#39; identified by &#39;密码&#39; with grant option;c. 刷新权限：flush privileges;­]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用指令]]></title>
    <url>%2F2017%2F05%2F23%2Fgit%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Git(读音为/gɪt/。)是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 [1] Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 1.基本指令git init &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; —— 新建git仓库git add 文件/文件夹 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; —— 将文件添加到缓存区中git add -A &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; — 添加所有内容到缓存区中git stutas &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——— 查看git状态git commit -m ‘提交信息’ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 将缓存区中的内容全部提交到git本地仓库中 git log &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——- 查看提交日志 git reset - - hard HEAD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 让工作目录中的内容和仓库中的内容保持一致git reset --hard HEAD^ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 回到上一个版本git reset - - hard 版本号 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 回到指定的版本git checkout - - 文件名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; —— 从暂存区中恢复工作目录中的内容(让工作区中的指定文件，回到上次提交的时候的状态) git clone &lt;url&gt; - 将服务器上的项目(仓库)克隆 (使用https地址需要输入密码，使用ssh地址需要添加公钥) git remote add origin 地址 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—– 关联远程仓库(只需要关联一次) git push [-u] origin master &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—– 提交(-u在第一次提交分之的时候才用) 2.分之管理创建仓库会默认给我们创建一个master分之,这个分之一般作为提交和发布分之;开发一般会自己创建一个develop分之，用来开发和测试;多人协作的时候还可能根据不同的人或者(不同的功能)创建不同的分之，用来独立开发 常见分之： master(主要是合并develop), develop(主要合并下面的其他分支), 功能/人员分之(开发) git branch [-a] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 查看分之git branch 分之名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 创建分之git checkout 分支名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 切换分之git checkout -b 分之名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 切换并创建新的分之git diff 分之1 分之2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 查看两个分之之间的差异git merge 分之名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 让当前分之和指定分之进行合并 注意: 切换分之、push、pull，这些操作前要保证工作区是clean 怎么避免冲突： 不要发生多个分之对同一个文件在同一个版本下进行修改(和同伴确认和商量)]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好呀!]]></title>
    <url>%2F2017%2F05%2F20%2F%E4%BD%A0%E5%A5%BD%E5%91%80%2F</url>
    <content type="text"><![CDATA[这篇只是自己的一些杂谈，可看可不看。 你好呀！ 匆匆忙忙的把个人的博客搭建好了，git,Hexo都了解到了一点皮毛，好友很多等着我去发现。目前来说只是记录自己的生活和自己的技术成长，可能技术更多一点。希望各位看到的大佬能帮助我这个小白，多谢。 博客的搭建参考了很多大佬的分享，但是忘记保存地址了所以，在此表示歉意。以后一定记得。 加油！小白求指导]]></content>
  </entry>
</search>
